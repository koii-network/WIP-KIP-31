import {Connection, PublicKey, Keypair} from '@_koii/web3.js';

import {RawTaskData, FileUploadResponse, InitOptions} from './Interfaces';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import nacl from 'tweetnacl';
import bs58 from 'bs58';

export class KoiiStorageClient {
  private static instance: KoiiStorageClient;
  private storageTaskId: string;
  private k2URL: string;
  private taskState: any;
  private trustedNodes = ['https://ipfs-gateway.koii.live', 'https://tasknet.koii.live', 'https://tasknet-2.koii.live'];
  private debug;

  private constructor(storageTaskId?: string, k2URL = 'https://testnet.koii.network', debug = false) {
    if (storageTaskId) this.storageTaskId = storageTaskId;
    else this.storageTaskId = 'BWfeCA4gyVKpmKGpq6MDHir16p7i2Er1e8XEHQj7z7zm';
    this.k2URL = k2URL;
    this.debug = debug;
    this.watchTaskState();
  }

  private async watchTaskState() {
    await this.getTaskState();
    setInterval(() => {
      this.getTaskState();
    }, 10 * 60 * 1000);
  }

  async uploadFile(file: string | File | File[], stakingWallet: Keypair): Promise<FileUploadResponse> {
    if (!stakingWallet) throw new Error('Staking wallet is required');
    const nodesUrls = await this.getNodesRunningTask(7);
    if (this.debug) console.log(nodesUrls);
    const formData = new FormData();
    let fileData;

    if (typeof file === 'string') {
      // Normalize the file path
      const normalizedPath = path.normalize(file).replace(/\\/g, '/');
      // If a single file path is provided, read the file synchronously
      fileData = fs.readFileSync(normalizedPath);
      const fileBlob = new Blob([fileData]);
      const filename = path.basename(file);
      formData.append('files', fileBlob, filename);
    } else if (file instanceof File) {
      // If a single File object is provided
      fileData = Buffer.from(await file.arrayBuffer());
      formData.append('files', file);
      // formData.append('name', file.name);
    } else if (Array.isArray(file)) {
      // If an array of File objects is provided
      const fileBuffers = await Promise.all(file.map(async (f) => Buffer.from(await f.arrayBuffer())));
      fileData = Buffer.concat(fileBuffers);
      file.forEach((f) => {
        formData.append('files', f);
        // formData.append('name', f.name);
      });
    } else {
      throw new Error('Invalid file input');
    }

    const fileHash = await this.hashFileData(fileData);
    const signature = await this.signingFileHash(fileHash, stakingWallet);

    formData.append('signature', signature);
    formData.append('stakingWalletPubkey', stakingWallet.publicKey.toBase58());

    const errorList: any = [];
    const promises = nodesUrls.map(async (nodeUrl) => {
      try {
        const response = await this.fetchWithTimeout(`${nodeUrl}/task/${this.storageTaskId}/ipfs/add`, {
          // const response = await fetch(`http://localhost:20001/ipfs/add`, {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          if (this.debug) console.error(response.status, response.statusText);
          let responseText = await response.text();
          throw new Error(`Failed to upload file ${response.status} - ${response.statusText} - ${responseText}`);
        }

        return await response.json();
      } catch (error: any) {
        if (this.debug) console.error('Error Uploading file to node:', nodeUrl, error.message);
        errorList.push(error);
        return null; // Return null if there's an error
      }
    });

    const responses = await Promise.all(promises);
    // Filter out null responses and return the first valid response
    let successResp = responses.filter((response) => response !== null)[0];

    if (!successResp) {
      throw new Error('Failed to upload file' + errorList[errorList.length - 1]);
    }
    return successResp;
  }

  async getFile(cid: string, filename: string): Promise<Blob> {
    const nodesUrls = await this.getNodesRunningTask(5);
    let response: any;
    for (let nodeUrl of nodesUrls) {
      try {
        response = await this.fetchWithTimeout(`${nodeUrl}/task/${this.storageTaskId}/ipfs/${cid}/${filename}`);

        if (!response.ok) {
          if (this.debug) console.error(response.status, response.statusText);
          throw new Error('Failed to fetch file from node');
        }
        const data = await response.blob();
        return data;
      } catch (error: any) {
        if (this.debug) console.error('Error fetching file from node:', nodeUrl, error.message);
      }
    }
    throw new Error('Cannot fetch the file: ' + response?.statusText);
  }
  async signingFileHash(fileHash: string, stakingWallet: Keypair) {
    const msg = new TextEncoder().encode(fileHash);
    const signedMessage = nacl.sign(msg, stakingWallet.secretKey);
    return await this.bs58Encode(signedMessage);
  }

  private async hashFileData(fileData: any, algorithm = 'sha256') {
    const hash = crypto.createHash(algorithm);
    hash.update(fileData);
    return hash.digest('hex');
  }

  private bs58Encode(data: any) {
    return bs58.encode(Buffer.from(data.buffer, data.byteOffset, data.byteLength));
  }
  private async getTaskState(): Promise<void> {
    const connection = new Connection(this.k2URL);
    let accountInfo;
    try {
      accountInfo = await connection.getAccountInfo(new PublicKey(this.storageTaskId));
    } catch (error) {
      this.taskState = {};
      return;
    }
    if (!accountInfo) {
      this.taskState = {};
      return;
    }
    const taskState: RawTaskData = JSON.parse(accountInfo.data + '');
    this.taskState = taskState;
    if (!taskState.is_active) throw new Error('Storage task is not active');
  }

  private async getNodesRunningTask(count: number): Promise<string[]> {
    let counter = 0;
    while (!this.taskState) {
      counter += 1;
      if (counter > 100) break;
      if (this.debug) console.log('Waiting for taskState fetching');
      await this.sleep(500);
    }
    const state: RawTaskData = this.taskState;
    if (!state || !state.submissions) {
      if (this.debug) console.log('Not able to fetch all nodes, falling back to trusted nodes');
      return this.trustedNodes;
    }
    let totalSubmissionKeys = Object.keys(state.submissions);
    const lastRound = totalSubmissionKeys[totalSubmissionKeys.length - 1];
    let lastRoundSubmissionKeys = Object.keys(state.submissions[lastRound]);
    let selectedNodes;
    if (lastRoundSubmissionKeys.length > 10) {
      const shuffledArray = this.shuffleArray(lastRoundSubmissionKeys.slice()); // Make a copy to avoid modifying the original array
      selectedNodes = shuffledArray.slice(0, count - 1);
    } else {
      selectedNodes = lastRoundSubmissionKeys.map((e) => state.ip_address_list[e]).filter((e) => !!e);
    }
    for (let trustedNode of this.trustedNodes) {
      if (!selectedNodes.includes(trustedNode)) selectedNodes.push(trustedNode);
    }
    return selectedNodes;
  }
  async saveBlobAsFile(blob: Blob, filename: string): Promise<void> {
    // Convert the Blob data to a Buffer
    const buffer = Buffer.from(await blob.arrayBuffer());

    // Write the Buffer data to a file
    fs.writeFileSync(filename, buffer);
  }

  private shuffleArray(array: string[]) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }
  private sleep(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  private fetchWithTimeout(url: string, options?: any, timeout = 20000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const signal = controller.signal;

    return fetch(url, {...options, signal}).finally(() => clearTimeout(id));
  }

  public static getInstance(options: InitOptions): KoiiStorageClient {
    if (!KoiiStorageClient.instance) {
      KoiiStorageClient.instance = new KoiiStorageClient(options?.storageTaskId, options?.k2URL, options?.debug);
    }
    return KoiiStorageClient.instance;
  }
}
